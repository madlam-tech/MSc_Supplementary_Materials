from enum import Enum
from typing import NamedTuple

# Classes imported from dependencies:
#     Bio.SeqRecord
#     Bio.SeqFeature

"""
The annotate module heavily leverages these two classes. 
    - The input genome is converted to a list of seqrecords, one for each chromosome / contig in the genbank file.
    - Each seqrecord contains a list of seqfeatures, which are all of the annotations. Every gene, CDS, RNA, intergenic
        region, etc. is a seqfeature.
    - The data types below are additional pieces of information that pseudofinder will collect about each feature. These
        can be accessed within each seqfeature by seqfeature.qualifiers, which is a dictionary of additional info.
    - For example, you can access a list of blast hits stored as List[BlastHit] through SeqFeature.qualifiers['hits'].
"""


class BlastHit(NamedTuple):  # An individual blast hit to a region.
    blast_type: str
    query: str
    subject_accession: str
    percent_ident: str
    length: int  # reported in aa for blastp and nt for blastx. see blasthit_length()
    mismatch: int
    gapopen: int
    q_start: int
    q_end: int
    s_start: int
    s_end: int
    evalue: int
    bitscore: float
    stitle: str


class SleuthData(NamedTuple):   # Data generated by the sleuth module
    reference_locus: str
    target_locus: str
    ani: float
    aai: float
    ref_length: float
    aln_query_cov: float
    start: bool
    loss_of_preferred_start: bool
    gain_of_preferred_start_codon: bool
    stop_codon: bool
    internal_stops: int
    first_stop_codon: int
    out_of_frame_inserts: int
    out_of_frame_dels: int
    inframe_inserts: int
    inframe_dels: int
    total_inserts: int
    total_deleted_bases: int
    ds: float
    ds_no_mercy: float
    dsds: float
    delta_ds: float
    dnds: float
    dnds_no_mercy: float
    full_seq: str
    mercy_aln: str
    no_mercy_aln: str
    full_ref_seq: str
    mercy_aln_ref: str
    no_mercy_aln_ref: str


class PseudoMetaData(NamedTuple):
    description: str
    dict_key: str
    log_name: str
    gff_reason: str
    show_in_log: bool

    def gff_reason_with_var(self, var):
        return self.gff_reason.replace("[variable]", var)


class PseudoType:  # Use this class to designate what kind of pseudogene a particular feature is.
    class Example(Enum):
        example1 = {
            'description': 'full description of the pseudogene type',
            'dict_key': 'to be used in StatisticsDict',
            'log_name': 'pseudo name as it should appear in the log file',
            'gff_reason': 'reason for pseudogene as it should appear in GFF file',
        }

    class Input(Enum):  # Pseudogenes declared in the original genbank file
        general = {
            'description': "Input gbk feature.type is 'pseudo' but we don't have a reason why",
            'dict_key': '',
            'log_name': ''
        }
        indel = {
            'description': "Input feature.seq is not a multiple of 3",
            'dict_key': '',
            'log_name': ''
        }
        internalstop = {
            'description': "Stop codon (*) is present in input feature.seq",
            'dict_key': '',
            'log_name': ''
        }

    class MultiIssue(Enum):
        general = {
            'description': "Pseudogene with multiple issues.",
            'dict_key': '',
            'log_name': ''
        }
        sleuth = {
            'description': "Pseudogene enriched with sleuth annotations",
            'dict_key': '',
            'log_name': ''
        }

    class Sleuth(Enum):  # Pseudogenes derived from the sleuth module
        dnds = {
            'description': "Pseudogene based on elevated dN/dS",
            'dict_key': '',
            'log_name': ''
        }
        frameshift = {
            'description': "Pseudogene based on significant frameshift-inducing indel(s)",
            'dict_key': '',
            'log_name': ''
        }
        start_codon = {
            'description': "Missing start codon",
            'dict_key': '',
            'log_name': ''
        }
        stop_codon = {
            'description': "Missing stop codon",
            'dict_key': '',
            'log_name': ''
        }
        internal_stop = {
            'description': "Internal stop codon",
            'dict_key': '',
            'log_name': ''
        }

    class Blast(Enum):  # Pseudogenes derived from blast results
        truncated = {
            'description': "CDS is too short based on length relative to blast hits",
            'dict_key': '',
            'log_name': '',
            'gff_reason': 'ORF is [variable] of the average length of hits to this gene.',
        }
        short_alignment = {
            'description': "Alignment of CDS to blast homologs is too short",
            'dict_key': '',
            'log_name': ''
        }
        long = {
            'description': "CDS is too long relative to blast hits",
            'dict_key': '',
            'log_name': ''
        }
        fragmented = {
            'description': "Pseudogene composed of multiple input features",
            'dict_key': '',
            'log_name': ''
        }
        intergenic = {
            'description': "Pseudogene recovered from intergenic space",
            'dict_key': '',
            'log_name': ''
        }

    class NotPseudo(Enum):  # Category for features that need a pseudotype but are not pseudogenes
        consumed = {
            'description': "Feature has been combined with other features (PseudoType.Blast.fragmented) and should no"
                           " longer be considered its own pseudogene",
            'dict_key': '',
            'log_name': ''
        }
        intergenic_consumed = {
            'description': "Feature was derived from intergenic space prior to being combined. This should not "
                           "count towards StatisticsDict[FragmentedOrfs]",
            'dict_key': '',
            'log_name': ''
        }
        intact = {
            'description': "Not a pseudogene",
            'dict_key': '',
            'log_name': ''
        }


# Global dictionary, which will be called to write the log file
StatisticsDict = {
    'NumberOfContigs': 0,
    'ProteomeOrfs': 0,
    'IntactORFs': 0,
    'PseudogenesInput': 0,
    'PseudogenesTotal': 0,
    'PseudogenesShort': 0,
    'PseudogenesLong': 0,
    'PseudogenesFragmented': 0,
    'PseudogenesIntergenic': 0,
    'PseudogenesDnds': 0,
    'PseudogenesFrameshift': 0,
    'PseudogenesStartCodon': 0,
    'PseudogenesStopCodon': 0,
    'PseudogenesInternalStop': 0,
    'PseudogenesMulti': 0,
    'FragmentedOrfs': 0
}
# x = [(k, v) for k, v in vars(PseudoType).items() if not str(k).startswith("__")]
# print(x)
#
# for item in x:
#     #print(vars(item[1]))
#     print([e.value for e in item[1]])

def add_pseudotypes_to_statisticsdict():
    pass